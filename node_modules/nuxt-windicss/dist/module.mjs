import { readFileSync, writeFileSync } from 'fs';
import { ensureDirSync } from 'fs-extra';
import { join, dirname, relative } from 'pathe';
import { createUtils } from '@windicss/plugin-utils';
import { resolveModule, defineNuxtModule, clearRequireCache, isNuxt3, isNuxt2, tryRequireModule, requireModule, extendWebpackConfig, extendViteConfig } from '@nuxt/kit';
import VitePluginWindicss from 'vite-plugin-windicss';
import consola from 'consola';
import { createApp } from 'h3';
import { ApiMiddleware } from 'windicss-analysis';
import { listen } from 'listhen';
import sirv from 'sirv';
import defu from 'defu';

// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);


const version = "2.3.1";

const logger = consola.withScope("nuxt-windicss");

async function analyze(runtime, options = {}) {
  if (typeof options === "boolean")
    options = {};
  const resolvedOptions = defu(options, {
    server: {
      port: 3330,
      showURL: false
    }
  });
  const app = createApp();
  app.use("/api", ApiMiddleware(runtime.windiOptions, { utils: runtime.utils, ...resolvedOptions.analysis }));
  app.use(sirv(join(dirname(resolveModule("windicss-analysis")), "app"), { dev: true, single: true }));
  return await listen(app, resolvedOptions.server);
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-windicss",
    configKey: "windicss",
    compatibility: {
      nuxt: "^2.0.0 || ^3.0.0-27430348.4ff1a95"
    }
  },
  defaults: {
    analyze: false,
    displayVersionInfo: true,
    scan: {
      dirs: ["./"],
      exclude: [
        "node_modules",
        "node_modules_dev",
        "node_modules_prod",
        "dist",
        ".git",
        ".github",
        ".nuxt",
        "coverage",
        "**/__snapshots__",
        "*.test.js"
      ]
    },
    preflight: {
      alias: {
        "nuxt-link": "a",
        "nuxt-img": "img"
      }
    },
    transformCSS: "pre"
  },
  async setup(options, nuxt) {
    const nuxtOptions = nuxt.options;
    if (!options.root)
      options.root = nuxt.options.rootDir;
    if (nuxtOptions.buildModules.includes("@nuxtjs/tailwindcss") || nuxtOptions.modules.includes("@nuxtjs/tailwindcss")) {
      logger.error("Sorry, you can't use Windi CSS with Tailwind CSS. Please remove the `@nuxtjs/tailwindcss` module.");
      return;
    }
    const ctxOnOptionsResolved = options.onOptionsResolved;
    options.onOptionsResolved = async (options2) => {
      if (ctxOnOptionsResolved) {
        const result = ctxOnOptionsResolved(options2);
        return typeof result === "object" ? result : options2;
      }
      await nuxt.callHook("windicss:options", options2);
      logger.debug("Post hook windicss:options", options2);
      return options2;
    };
    const ctxOnConfigResolved = options.onConfigResolved;
    let passed = false;
    options.onConfigResolved = async (windiConfig, configFilePath) => {
      if (!passed) {
        let configType = "inline";
        if (configFilePath) {
          clearRequireCache(configFilePath);
          configType = `./${relative(nuxtOptions.rootDir, configFilePath)}`;
          if (nuxt.options.dev)
            nuxt.options.watch.push(configFilePath);
        }
        if (options.displayVersionInfo && nuxt.options.dev) {
          nuxt.hook("build:before", () => {
            logger.info(`\`nuxt-windicss v${version}\` running with config: \`${configType}\`.`);
          });
        }
        passed = true;
      }
      if (ctxOnConfigResolved) {
        const result = await ctxOnConfigResolved(windiConfig, configFilePath);
        return typeof result === "object" ? result : windiConfig;
      }
      await nuxt.callHook("windicss:config", windiConfig);
      logger.debug("Post hook windicss:config", windiConfig);
      return windiConfig;
    };
    const utils = createUtils(options, { root: options.root, name: "nuxt-windicss" });
    const ensureInit = utils.init().then(() => nuxt.callHook("windicss:utils", utils));
    const windiImports = nuxt.options.css.filter((css) => (typeof css === "string" ? css : css.src).includes("virtual:windi"));
    if (!windiImports.length)
      nuxt.options.css.unshift("virtual:windi.css");
    if (isNuxt3(nuxt) && nuxt.options.vite === false) {
      nuxt.options.css = nuxt.options.css.map((css) => {
        if (!css.includes("virtual:windi") || css.startsWith("@"))
          return css;
        return join("@", css);
      });
    }
    if (isNuxt2(nuxt)) {
      nuxt.hook("build:templates", ({ templateVars, templatesFiles }) => {
        templateVars.css = templateVars.css.map((css) => {
          const src = typeof css === "string" ? css : css.src;
          if (src.includes("virtual:windi")) {
            return {
              src,
              virtual: true
            };
          }
          return css;
        });
        templatesFiles.map((template) => {
          if (!template.src.endsWith("App.js"))
            return template;
          const file = readFileSync(template.src, { encoding: "utf-8" });
          const regex = /(import '<%= )(relativeToBuild\(resolvePath\(c\.src \|\| c, { isStyle: true }\)\))( %>')/gm;
          const subst = "$1c.virtual ? c.src : $2$3";
          const appTemplate = file.replace(regex, subst);
          ensureDirSync(join(__dirname, "runtime"));
          const newPath = join(__dirname, "runtime", "App.js");
          writeFileSync(newPath, appTemplate);
          template.src = newPath;
          return template;
        });
      });
    }
    nuxt.hook("build:before", async () => {
      const nuxtPostcss = nuxt.options.postcss || nuxt.options.build.postcss.postcssOptions || nuxt.options.build.postcss;
      if (!nuxtPostcss)
        return;
      const hasPostCSSImport = tryRequireModule("postcss-import");
      if (!hasPostCSSImport)
        return;
      const readCache = requireModule("read-cache");
      const updatedPostcssImport = {
        async load(filename) {
          await ensureInit;
          const file = await readCache(filename, "utf-8");
          return utils.transformCSS(file, filename);
        }
      };
      nuxtPostcss.plugins = nuxtPostcss.plugins || {};
      nuxtPostcss.plugins["postcss-import"] = {
        ...nuxtPostcss.plugins["postcss-import"],
        ...updatedPostcssImport
      };
    });
    extendWebpackConfig((config) => {
      const WindiCSSWebpackPlugin = requireModule("windicss-webpack-plugin");
      const plugin = new WindiCSSWebpackPlugin({ ...options, utils });
      config.plugins = config.plugins || [];
      config.plugins.push(plugin);
    });
    extendViteConfig(async (config) => {
      const plugin = VitePluginWindicss(options, { root: options.root, utils, name: "nuxt-windicss" });
      nuxt.options.alias["windi.css"] = "virtual:windi.css";
      config.plugins = config.plugins || [];
      config.plugins.unshift(...plugin);
    });
    if (nuxtOptions.dev) {
      nuxt.hook("content:file:beforeParse", async (file) => {
        if (file.extension !== ".md")
          return;
        await ensureInit;
        await utils.extractFile(file.data, file.path, true);
        const css = await utils.generateCSS();
        file.data += `

<style>${css}</style>`;
      });
      if (options.analyze !== false) {
        let serverStarted = false;
        nuxt.hook("listen", () => {
          serverStarted = true;
        });
        analyze({
          windiOptions: options,
          utils
        }, options.analyze).then((server) => {
          const message = `WindCSS Analysis: ${server.url}`;
          if (isNuxt3(nuxt)) {
            logger.info(message);
          } else if (serverStarted) {
            nuxt.hook("build:done", () => {
              serverStarted = true;
              logger.info(message);
            });
          } else {
            nuxt.options.cli.badgeMessages.push(message);
          }
        });
      }
    }
  }
});

export { module as default };
