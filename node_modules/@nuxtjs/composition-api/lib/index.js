'use strict';

const upath = require('upath');
const ufo = require('ufo');

const foolWebpack = (id) => require(id);
const loadUtils = () => {
  try {
    return foolWebpack("@nuxt/utils-edge");
  } catch (e) {
    return foolWebpack("@nuxt/utils");
  }
};
const isUrl = function isUrl2(url) {
  return ["http", "//"].some((str) => url.startsWith(str));
};
const compositionApiModule = function compositionApiModule2() {
  var _a, _b, _c, _d;
  const utils = loadUtils();
  const {readdirSync, copyFileSync, existsSync, mkdirpSync} = foolWebpack("fs-extra");
  let corejsPolyfill = this.nuxt.options.build.corejs ? String(this.nuxt.options.build.corejs) : void 0;
  try {
    if (!["2", "3"].includes(corejsPolyfill || "")) {
      const corejsPkg = require("core-js/package.json");
      corejsPolyfill = corejsPkg.version.slice(0, 1);
    }
  } catch (e) {
    corejsPolyfill = void 0;
  }
  const libRoot = upath.resolve(__dirname, "..");
  const {dst: pluginDst} = this.addTemplate({
    src: upath.resolve(libRoot, "templates", "plugin.js"),
    fileName: upath.join("composition-api", "plugin.js"),
    options: {
      corejsPolyfill
    }
  });
  const {dst: metaPluginDst} = this.addTemplate({
    src: upath.resolve(libRoot, "templates", "meta.js"),
    fileName: upath.join("composition-api", "meta.js")
  });
  const staticPath = upath.join(this.options.buildDir || "", "static-json");
  this.nuxt.hook("builder:prepared", () => {
    mkdirpSync(staticPath);
  });
  this.nuxt.hook("generate:route", () => {
    mkdirpSync(staticPath);
  });
  this.nuxt.hook("generate:done", async (generator) => {
    if (!existsSync(staticPath))
      return;
    const {distPath} = generator;
    readdirSync(staticPath).forEach((file) => copyFileSync(upath.join(staticPath, file), upath.join(distPath, file)));
  });
  const globalName = this.options.globalName || "nuxt";
  const globalContextFactory = ((_a = this.options.globals) == null ? void 0 : _a.context) || ((globalName2) => `__${globalName2.toUpperCase()}__`);
  const globalNuxtFactory = ((_b = this.options.globals) == null ? void 0 : _b.nuxt) || ((globalName2) => `$${globalName2}`);
  const globalContext = globalContextFactory(globalName);
  const globalNuxt = globalNuxtFactory(globalName);
  const routerBase = ufo.withTrailingSlash((_c = this.options.router) == null ? void 0 : _c.base);
  const publicPath = ufo.withTrailingSlash((_d = this.options.build) == null ? void 0 : _d.publicPath);
  const {dst: entryDst} = this.addTemplate({
    src: upath.resolve(libRoot, "lib", "entrypoint.es.js"),
    fileName: upath.join("composition-api", "index.js"),
    options: {
      isFullStatic: "isFullStatic" in utils && utils.isFullStatic(this.nuxt.options),
      staticPath,
      publicPath: isUrl(publicPath) ? publicPath : routerBase,
      globalContext,
      globalNuxt
    }
  });
  this.options.build = this.options.build || {};
  this.options.build.babel = this.options.build.babel || {};
  this.options.build.babel.plugins = this.options.build.babel.plugins || [];
  if (this.options.build.babel.plugins instanceof Function) {
    console.warn("Unable to automatically add Babel plugin. Make sure your custom `build.babel.plugins` returns `@nuxtjs/composition-api/babel`");
  } else {
    this.options.build.babel.plugins.push(upath.join(__dirname, "babel"));
  }
  this.options.build.transpile = this.options.build.transpile || [];
  this.options.build.transpile.push(/@nuxtjs[\\/]composition-api/);
  const actualPresets = this.options.build.babel.presets;
  this.options.build.babel.presets = (env, [defaultPreset, defaultOptions]) => {
    const newOptions = {
      ...defaultOptions,
      jsx: {
        ...typeof defaultOptions.jsx === "object" ? defaultOptions.jsx : {},
        compositionAPI: true
      }
    };
    if (typeof actualPresets === "function") {
      return actualPresets(env, [defaultPreset, newOptions]);
    }
    return [[defaultPreset, newOptions]];
  };
  this.extendBuild((config) => {
    config.resolve = config.resolve || {};
    config.resolve.alias = config.resolve.alias || {};
    config.resolve.alias["@nuxtjs/composition-api"] = upath.resolve(this.options.buildDir || "", entryDst);
  });
  this.options.plugins = this.options.plugins || [];
  this.options.plugins.unshift(upath.resolve(this.options.buildDir || "", pluginDst));
  if (!(this.nuxt.options.buildModules || []).includes("@nuxtjs/pwa") && !this.nuxt.options.modules.includes("@nuxtjs/pwa")) {
    this.options.plugins.push(upath.resolve(this.options.buildDir || "", metaPluginDst));
  } else if (this.nuxt.options.dev) {
    console.warn("useMeta is not supported in onGlobalSetup as @nuxtjs/pwa detected.\nSee https://github.com/nuxt-community/composition-api/issues/307");
  }
};
compositionApiModule.meta = require("../package.json");
const warnToAddModule = () => {
  console.error("You need to add `@nuxtjs/composition-api` to your buildModules in order to use it. See https://composition-api.nuxtjs.org/getting-started/setup.");
  throw new Error("You need to add `@nuxtjs/composition-api` to your buildModules in order to use it. See https://composition-api.nuxtjs.org/getting-started/setup.");
};
Object.keys(require("./entrypoint")).forEach((helper) => {
  compositionApiModule[helper] = warnToAddModule;
});
compositionApiModule.defineNuxtConfig = (config) => config;

module.exports = compositionApiModule;
